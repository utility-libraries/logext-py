{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"loggext","text":""},{"location":"#loggext","title":"loggext","text":"<p>logging extensions for pythons logging library</p>"},{"location":"#features","title":"Features","text":"<ul> <li>function-decorators for logging<ul> <li>with support for asnyc-functions</li> </ul> </li> <li>additional logging-handlers<ul> <li>ColoredConsoleHandler</li> </ul> </li> <li>format-builder</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>The installation is as simple as possible</p> <pre><code>pip install loggext\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>loggext<ul> <li>decorators<ul> <li>add_logging</li> </ul> </li> <li>extradata<ul> <li>hostname</li> <li>program_name</li> <li>short_name</li> <li>username</li> </ul> </li> <li>formatting<ul> <li>builder</li> <li>default_formats</li> </ul> </li> <li>handlers<ul> <li>colored</li> </ul> </li> <li>utility</li> </ul> </li> </ul>"},{"location":"reference/loggext/","title":"loggext","text":""},{"location":"reference/loggext/#loggext.StandardColors","title":"<code>StandardColors</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>collection of standard colors for the terminal</p> Source code in <code>src/loggext/utility/_color.py</code> <pre><code>class StandardColors(enum.IntEnum):\n    r\"\"\"\n    collection of standard colors for the terminal\n    \"\"\"\n\n    def __new__(cls, ansi_code: int, rgb: t.Tuple[int, int, int], hexadecimal: str) -&gt; t.NoReturn:\n        obj = int.__new__(cls, ansi_code)\n        obj._value_ = ansi_code\n        obj.ansi_code = ansi_code\n        obj.rgb = rgb\n        obj.hexadecimal = hexadecimal\n        # normal color: 30fg/40bg | bright colors 90fg/100bg\n        obj.escape_code_fg = f\"\\033[{(30 + ansi_code) if ansi_code &lt; 0x8 else (82 + ansi_code)}m\"\n        obj.escape_code_bg = f\"\\033[{(40 + ansi_code) if ansi_code &lt; 0x8 else (92 + ansi_code)}m\"\n        return obj\n\n    BLACK           = 0x0, (0,   0,   0),   \"#000000\"\n    RED             = 0x1, (204, 0,   0),   \"#CC0000\"\n    GREEN           = 0x2, (78,  154, 6),   \"#4E9A06\"\n    YELLOW          = 0x3, (196, 160, 0),   \"#C4A000\"\n    BLUE            = 0x4, (114, 159, 207), \"#729FCF\"\n    MAGENTA         = 0x5, (117, 80,  123), \"#75507B\"\n    CYAN            = 0x6, (6,   152, 154), \"#06989A\"\n    WHITE           = 0x7, (211, 215, 207), \"#D3D7CF\"\n    BRIGHT_BLACK    = 0x8, (85,  87,  83),  \"#555753\"\n    BRIGHT_RED      = 0x9, (239, 41,  41),  \"#EF2929\"\n    BRIGHT_GREEN    = 0xA, (138, 226, 52),  \"#8AE234\"\n    BRIGHT_YELLOW   = 0xB, (252, 233, 79),  \"#FCE94F\"\n    BRIGHT_BLUE     = 0xC, (50,  175, 255), \"#32AFFf\"\n    BRIGHT_MAGENTA  = 0xD, (173, 127, 168), \"#AD7FA8\"\n    BRIGHT_CYAN     = 0xE, (52,  226, 226), \"#34E2E2\"\n    BRIGHT_WHITE    = 0xF, (255, 255, 255), \"#FFFFFF\"\n</code></pre>"},{"location":"reference/loggext/#loggext.is_running_as_service","title":"<code>is_running_as_service()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if the current script is running as a service (or not)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def is_running_as_service() -&gt; bool:\n    r\"\"\"\n    :return: if the current script is running as a service (or not)\n    \"\"\"\n    return os.getenv('TERM') is None and os.isatty(sys.stdin.fileno())\n</code></pre>"},{"location":"reference/loggext/#loggext.is_running_in_shell","title":"<code>is_running_in_shell()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if the current script is running in a shell (or not)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def is_running_in_shell() -&gt; bool:\n    r\"\"\"\n    :return: if the current script is running in a shell (or not)\n    \"\"\"\n    return os.isatty(sys.stdin.fileno())\n</code></pre>"},{"location":"reference/loggext/#loggext.logging_is_configured","title":"<code>logging_is_configured()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if :func:<code>logging.basicConfig</code> was already called. (if the root-logger has handlers)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def logging_is_configured() -&gt; bool:\n    r\"\"\"\n    :return: if :func:`logging.basicConfig` was already called. (if the root-logger has handlers)\n    \"\"\"\n    return len(logging.root.handlers) &gt; 0\n</code></pre>"},{"location":"reference/loggext/#loggext.no_multiprocess_info","title":"<code>no_multiprocess_info()</code>","text":"<p>disabled multiprocessing-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_multiprocess_info():\n    r\"\"\" disabled multiprocessing-information in the LogRecord for slight performance boost \"\"\"\n    logging.logMultiprocessing = False\n</code></pre>"},{"location":"reference/loggext/#loggext.no_process_info","title":"<code>no_process_info()</code>","text":"<p>disabled process-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_process_info():\n    r\"\"\" disabled process-information in the LogRecord for slight performance boost \"\"\"\n    logging.logProcess = False\n</code></pre>"},{"location":"reference/loggext/#loggext.no_thread_info","title":"<code>no_thread_info()</code>","text":"<p>disabled threading-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_thread_info():\n    r\"\"\" disabled threading-information in the LogRecord for slight performance boost \"\"\"\n    logging.logThreads = False\n</code></pre>"},{"location":"reference/loggext/decorators/","title":"loggext.decorators","text":""},{"location":"reference/loggext/decorators/#loggext.decorators.add_logging","title":"<code>add_logging(fn=None, *, logger=logging.root, call=True, call_args=True, timeit=True, timeit_precision=2, result=True)</code>","text":"<p>adds some logging messages to a function</p> <pre><code>&gt;&gt;&gt; @add_logging()\n... def foo():\n...     pass\n</code></pre> <p>Note</p> <p><code>add_logging</code> supports async functions</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>function to be decorated</p> <code>None</code> <code>logger</code> <code>Logger</code> <p>specific logger to use (otherwise root-logger)</p> <code>root</code> <code>call</code> <code>bool</code> <p>whether to log when the function is called</p> <code>True</code> <code>call_args</code> <code>bool</code> <p>whether to log the functions call arguments (only with <code>call=True</code>)</p> <code>True</code> <code>timeit</code> <code>bool</code> <p>whether to log the functions execution time</p> <code>True</code> <code>timeit_precision</code> <code>int</code> <p>precision of the logged execution time (only with <code>timeit=True</code>)</p> <code>2</code> <code>result</code> <code>bool</code> <p>whether to log the returned value of the function</p> <code>True</code> Source code in <code>src/loggext/decorators/add_logging.py</code> <pre><code>def add_logging(\n        fn: t.Callable = None,\n        *, logger: logging.Logger = logging.root,\n        call: bool = True,\n        call_args: bool = True,\n        timeit: bool = True,\n        timeit_precision: int = 2,\n        result: bool = True,\n        ):\n    r\"\"\"\n    adds some logging messages to a function\n\n    ```pycon\n\n    &gt;&gt;&gt; @add_logging()\n    ... def foo():\n    ...     pass\n\n    ```\n\n    !!! note\n        `add_logging` supports async functions\n\n    :param fn: function to be decorated\n    :param logger: specific logger to use (otherwise root-logger)\n    :param call: whether to log when the function is called\n    :param call_args: whether to log the functions call arguments (only with `call=True`)\n    :param timeit: whether to log the functions execution time\n    :param timeit_precision: precision of the logged execution time (only with `timeit=True`)\n    :param result: whether to log the returned value of the function\n    \"\"\"\n    def decorator(func: t.Callable) -&gt; t.Callable:\n        if iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def wrapper(*args, **kwargs):\n                timing = timer(precision=timeit_precision)\n                try:\n                    if logger.isEnabledFor(logging.DEBUG) and call:\n                        message = f\"{func} was called\"\n                        if call_args:\n                            message += f\" with ({_format_args(*args, **kwargs)})\"\n                        logger.debug(message)\n                    res = await func(*args, **kwargs)\n                    if logger.isEnabledFor(logging.DEBUG) and (result or timeit):\n                        resfmt = f\" {res!r}\" if result else \"\"\n                        timefmt = f\" after {next(timing)}\" if timeit else \"\"\n                        logger.debug(f\"{func} returned{resfmt}{timefmt}\")\n                    return res\n                except BaseException as exc:\n                    message = f\"{func} raised {type(exc).__qualname__}\"\n                    if timeit:\n                        message += f\" after {next(timing)}\"\n                    logger.exception(message, exc_info=exc)\n                    raise exc\n        else:\n            @functools.wraps(func)\n            def wrapper(*args, **kwargs):\n                timing = timer(precision=timeit_precision)\n                try:\n                    if logger.isEnabledFor(logging.DEBUG) and call:\n                        message = f\"{func} was called\"\n                        if call_args:\n                            message += f\" with ({_format_args(*args, **kwargs)})\"\n                        logger.debug(message)\n                    res = func(*args, **kwargs)\n                    if logger.isEnabledFor(logging.DEBUG) and (result or timeit):\n                        resfmt = f\" {res!r}\" if result else \"\"\n                        timefmt = f\" after {next(timing)}\" if timeit else \"\"\n                        logger.debug(f\"{func} returned{resfmt}{timefmt}\")\n                    return res\n                except BaseException as exc:\n                    message = f\"{func} raised {type(exc).__qualname__}\"\n                    if timeit:\n                        message += f\" after {next(timing)}\"\n                    logger.exception(message, exc_info=exc)\n                    raise exc\n\n        return wrapper\n\n    return decorator if fn is None else decorator(func=fn)\n</code></pre>"},{"location":"reference/loggext/decorators/add_logging/","title":"loggext.decorators.add_logging","text":"<p>adds some logging messages to a function</p> <pre><code>&gt;&gt;&gt; @add_logging()\n... def foo():\n...     pass\n</code></pre> <p>Note</p> <p><code>add_logging</code> supports async functions</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>function to be decorated</p> <code>None</code> <code>logger</code> <code>Logger</code> <p>specific logger to use (otherwise root-logger)</p> <code>root</code> <code>call</code> <code>bool</code> <p>whether to log when the function is called</p> <code>True</code> <code>call_args</code> <code>bool</code> <p>whether to log the functions call arguments (only with <code>call=True</code>)</p> <code>True</code> <code>timeit</code> <code>bool</code> <p>whether to log the functions execution time</p> <code>True</code> <code>timeit_precision</code> <code>int</code> <p>precision of the logged execution time (only with <code>timeit=True</code>)</p> <code>2</code> <code>result</code> <code>bool</code> <p>whether to log the returned value of the function</p> <code>True</code> Source code in <code>src/loggext/decorators/add_logging.py</code> <pre><code>def add_logging(\n        fn: t.Callable = None,\n        *, logger: logging.Logger = logging.root,\n        call: bool = True,\n        call_args: bool = True,\n        timeit: bool = True,\n        timeit_precision: int = 2,\n        result: bool = True,\n        ):\n    r\"\"\"\n    adds some logging messages to a function\n\n    ```pycon\n\n    &gt;&gt;&gt; @add_logging()\n    ... def foo():\n    ...     pass\n\n    ```\n\n    !!! note\n        `add_logging` supports async functions\n\n    :param fn: function to be decorated\n    :param logger: specific logger to use (otherwise root-logger)\n    :param call: whether to log when the function is called\n    :param call_args: whether to log the functions call arguments (only with `call=True`)\n    :param timeit: whether to log the functions execution time\n    :param timeit_precision: precision of the logged execution time (only with `timeit=True`)\n    :param result: whether to log the returned value of the function\n    \"\"\"\n    def decorator(func: t.Callable) -&gt; t.Callable:\n        if iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def wrapper(*args, **kwargs):\n                timing = timer(precision=timeit_precision)\n                try:\n                    if logger.isEnabledFor(logging.DEBUG) and call:\n                        message = f\"{func} was called\"\n                        if call_args:\n                            message += f\" with ({_format_args(*args, **kwargs)})\"\n                        logger.debug(message)\n                    res = await func(*args, **kwargs)\n                    if logger.isEnabledFor(logging.DEBUG) and (result or timeit):\n                        resfmt = f\" {res!r}\" if result else \"\"\n                        timefmt = f\" after {next(timing)}\" if timeit else \"\"\n                        logger.debug(f\"{func} returned{resfmt}{timefmt}\")\n                    return res\n                except BaseException as exc:\n                    message = f\"{func} raised {type(exc).__qualname__}\"\n                    if timeit:\n                        message += f\" after {next(timing)}\"\n                    logger.exception(message, exc_info=exc)\n                    raise exc\n        else:\n            @functools.wraps(func)\n            def wrapper(*args, **kwargs):\n                timing = timer(precision=timeit_precision)\n                try:\n                    if logger.isEnabledFor(logging.DEBUG) and call:\n                        message = f\"{func} was called\"\n                        if call_args:\n                            message += f\" with ({_format_args(*args, **kwargs)})\"\n                        logger.debug(message)\n                    res = func(*args, **kwargs)\n                    if logger.isEnabledFor(logging.DEBUG) and (result or timeit):\n                        resfmt = f\" {res!r}\" if result else \"\"\n                        timefmt = f\" after {next(timing)}\" if timeit else \"\"\n                        logger.debug(f\"{func} returned{resfmt}{timefmt}\")\n                    return res\n                except BaseException as exc:\n                    message = f\"{func} raised {type(exc).__qualname__}\"\n                    if timeit:\n                        message += f\" after {next(timing)}\"\n                    logger.exception(message, exc_info=exc)\n                    raise exc\n\n        return wrapper\n\n    return decorator if fn is None else decorator(func=fn)\n</code></pre>"},{"location":"reference/loggext/extradata/","title":"loggext.extradata","text":"<pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logging.getLogger().addFilter(HostnameField() | ProgramNameField())\n</code></pre>"},{"location":"reference/loggext/extradata/#loggext.extradata.HostnameField","title":"<code>HostnameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Finds the hostname and adds it to the LogRecord as <code>hostname</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; HostnameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/hostname.py</code> <pre><code>class HostnameField(DataProvider):\n    r\"\"\"\n    Finds the hostname and adds it to the LogRecord as `hostname`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; HostnameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _hostname(self) -&gt; str:\n        import socket\n        return socket.gethostname()\n\n    def add_data(self, record):\n        record.hostname = self._hostname()\n</code></pre>"},{"location":"reference/loggext/extradata/#loggext.extradata.ProgramNameField","title":"<code>ProgramNameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Selects a suitable program-name and adds it to the LogRecord as <code>programName</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; ProgramNameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/program_name.py</code> <pre><code>class ProgramNameField(DataProvider):\n    r\"\"\"\n    Selects a suitable program-name and adds it to the LogRecord as `programName`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; ProgramNameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _program_name(self) -&gt; str:\n        import sys\n        import os.path as p\n\n        if sys.argv and sys.argv[0] != \"-c\":\n            return p.basename(sys.argv[0])\n        main = sys.modules.get('__main__')\n        if main and hasattr(main, '__file__'):\n            return p.basename(main.__file__)\n        if sys.executable:\n            return p.basename(sys.executable)\n        return \"python\"\n\n    def add_data(self, record):\n        record.programName = self._program_name()\n</code></pre>"},{"location":"reference/loggext/extradata/#loggext.extradata.ShortNameField","title":"<code>ShortNameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Shortens the name of the current logger and adds it to the LogRecord as <code>shortName</code>. This can heavily decrease the size of your log-files in exchange for losing some clarity.</p> <p>Example</p> <p><code>project.custom.module</code> -&gt; <code>p.c.module</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; ShortNameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/short_name.py</code> <pre><code>class ShortNameField(DataProvider):\n    r\"\"\"\n    Shortens the name of the current logger and adds it to the LogRecord as `shortName`.\n    This can heavily decrease the size of your log-files in exchange for losing some clarity.\n\n    !!! example\n        `project.custom.module` -&gt; `p.c.module`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; ShortNameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _short_name(self, name: str) -&gt; str:\n        *head, tail = name.split('.')\n        return '.'.join(tuple(p[0] for p in head) + (tail,))\n\n    def add_data(self, record):\n        print(f\"Adding ShortNameField for {record.name}\")\n        record.shortName = self._short_name(record.name)\n</code></pre>"},{"location":"reference/loggext/extradata/#loggext.extradata.UsernameField","title":"<code>UsernameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Finds the username and adds it to the LogRecord as <code>username</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; UsernameField().install()\n</code></pre> <p>Info</p> <p>On UNIX systems this uses the :mod:<code>pwd</code> module which means <code>root</code> will be reported when :man:<code>sudo</code> is used (as it should). If this fails (for example on Windows) then :func:<code>getpass.getuser()</code> is used as a fallback.</p> Source code in <code>src/loggext/extradata/username.py</code> <pre><code>class UsernameField(DataProvider):\n    r\"\"\"\n    Finds the username and adds it to the LogRecord as `username`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; UsernameField().install()\n        ```\n\n    !!! info\n        On UNIX systems this uses the :mod:`pwd` module which means ``root`` will\n        be reported when :man:`sudo` is used (as it should). If this fails (for\n        example on Windows) then :func:`getpass.getuser()` is used as a fallback.\n    \"\"\"\n\n    @cache\n    def _username(self) -&gt; str:\n        try:\n            import pwd, os\n            uid = os.getuid()\n            return pwd.getpwuid(uid).pw_name\n        except (ImportError, KeyError):\n            import getpass\n            return getpass.getuser()\n\n    def add_data(self, record):\n        record.username = self._username()\n</code></pre>"},{"location":"reference/loggext/extradata/hostname/","title":"loggext.extradata.hostname","text":""},{"location":"reference/loggext/extradata/hostname/#loggext.extradata.hostname.HostnameField","title":"<code>HostnameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Finds the hostname and adds it to the LogRecord as <code>hostname</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; HostnameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/hostname.py</code> <pre><code>class HostnameField(DataProvider):\n    r\"\"\"\n    Finds the hostname and adds it to the LogRecord as `hostname`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; HostnameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _hostname(self) -&gt; str:\n        import socket\n        return socket.gethostname()\n\n    def add_data(self, record):\n        record.hostname = self._hostname()\n</code></pre>"},{"location":"reference/loggext/extradata/program_name/","title":"loggext.extradata.program_name","text":""},{"location":"reference/loggext/extradata/program_name/#loggext.extradata.program_name.ProgramNameField","title":"<code>ProgramNameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Selects a suitable program-name and adds it to the LogRecord as <code>programName</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; ProgramNameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/program_name.py</code> <pre><code>class ProgramNameField(DataProvider):\n    r\"\"\"\n    Selects a suitable program-name and adds it to the LogRecord as `programName`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; ProgramNameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _program_name(self) -&gt; str:\n        import sys\n        import os.path as p\n\n        if sys.argv and sys.argv[0] != \"-c\":\n            return p.basename(sys.argv[0])\n        main = sys.modules.get('__main__')\n        if main and hasattr(main, '__file__'):\n            return p.basename(main.__file__)\n        if sys.executable:\n            return p.basename(sys.executable)\n        return \"python\"\n\n    def add_data(self, record):\n        record.programName = self._program_name()\n</code></pre>"},{"location":"reference/loggext/extradata/short_name/","title":"loggext.extradata.short_name","text":""},{"location":"reference/loggext/extradata/short_name/#loggext.extradata.short_name.ShortNameField","title":"<code>ShortNameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Shortens the name of the current logger and adds it to the LogRecord as <code>shortName</code>. This can heavily decrease the size of your log-files in exchange for losing some clarity.</p> <p>Example</p> <p><code>project.custom.module</code> -&gt; <code>p.c.module</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; ShortNameField().install()\n</code></pre> Source code in <code>src/loggext/extradata/short_name.py</code> <pre><code>class ShortNameField(DataProvider):\n    r\"\"\"\n    Shortens the name of the current logger and adds it to the LogRecord as `shortName`.\n    This can heavily decrease the size of your log-files in exchange for losing some clarity.\n\n    !!! example\n        `project.custom.module` -&gt; `p.c.module`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; ShortNameField().install()\n        ```\n    \"\"\"\n\n    @cache\n    def _short_name(self, name: str) -&gt; str:\n        *head, tail = name.split('.')\n        return '.'.join(tuple(p[0] for p in head) + (tail,))\n\n    def add_data(self, record):\n        print(f\"Adding ShortNameField for {record.name}\")\n        record.shortName = self._short_name(record.name)\n</code></pre>"},{"location":"reference/loggext/extradata/username/","title":"loggext.extradata.username","text":""},{"location":"reference/loggext/extradata/username/#loggext.extradata.username.UsernameField","title":"<code>UsernameField</code>","text":"<p>               Bases: <code>DataProvider</code></p> <p>Finds the username and adds it to the LogRecord as <code>username</code></p> <p>Example</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; UsernameField().install()\n</code></pre> <p>Info</p> <p>On UNIX systems this uses the :mod:<code>pwd</code> module which means <code>root</code> will be reported when :man:<code>sudo</code> is used (as it should). If this fails (for example on Windows) then :func:<code>getpass.getuser()</code> is used as a fallback.</p> Source code in <code>src/loggext/extradata/username.py</code> <pre><code>class UsernameField(DataProvider):\n    r\"\"\"\n    Finds the username and adds it to the LogRecord as `username`\n\n    !!! example\n        ```pycon\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; UsernameField().install()\n        ```\n\n    !!! info\n        On UNIX systems this uses the :mod:`pwd` module which means ``root`` will\n        be reported when :man:`sudo` is used (as it should). If this fails (for\n        example on Windows) then :func:`getpass.getuser()` is used as a fallback.\n    \"\"\"\n\n    @cache\n    def _username(self) -&gt; str:\n        try:\n            import pwd, os\n            uid = os.getuid()\n            return pwd.getpwuid(uid).pw_name\n        except (ImportError, KeyError):\n            import getpass\n            return getpass.getuser()\n\n    def add_data(self, record):\n        record.username = self._username()\n</code></pre>"},{"location":"reference/loggext/formatting/","title":"loggext.formatting","text":""},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder","title":"<code>LoggingFormatBuilder</code>","text":"<pre><code>&gt;&gt;&gt; logging_format: str = LoggingFormatBuilder(separator=\" | \") \\\n...     .add_asctime() \\\n...     .add_levelname(\".3\") \\\n...     .add_module(\"&lt;10\") \\\n...     .add_lineno(\"&gt;3\") \\\n...     .add_message() \\\n...     .build()\n</code></pre> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>class LoggingFormatBuilder:\n    r\"\"\"\n    ```pycon\n\n    &gt;&gt;&gt; logging_format: str = LoggingFormatBuilder(separator=\" | \") \\\n    ...     .add_asctime() \\\n    ...     .add_levelname(\".3\") \\\n    ...     .add_module(\"&lt;10\") \\\n    ...     .add_lineno(\"&gt;3\") \\\n    ...     .add_message() \\\n    ...     .build()\n\n    ```\n    \"\"\"\n\n    _separator: str\n    _parts: t.List[str]\n\n    def __init__(self, *, separator: str = \":\"):\n        self._separator = separator\n        self._parts = []\n\n    def build(self) -&gt; str:\n        r\"\"\" create the final logging-format \"\"\"\n        return self._separator.join(self._parts)\n\n    def add_field(self, name: str, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" adds a custom field \"\"\"\n        if fmt is None:\n            self._parts.append(f\"{{{name}}}\")\n        else:\n            self._parts.append(f\"{{{name}:{fmt}}}\")\n        return self\n\n    def add_literal(self, literal: str) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" adds a literal string as given \"\"\"\n        self._parts.append(literal)\n        return self\n\n    def add_asctime(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\"\n        Human-readable time when the LogRecord was created.\n        By default, this is of the form \u20182003-07-08 16:49:45,896\u2019\n        (the numbers after the comma are millisecond portion of the time).\n        \"\"\"\n        return self.add_field('asctime', fmt)\n\n    def add_created(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Time when the LogRecord was created (as returned by time.time()). \"\"\"\n        return self.add_field('created', fmt)\n\n    def add_filename(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Filename portion of pathname. \"\"\"\n        return self.add_field('filename', fmt)\n\n    def add_funcname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Name of function containing the logging call. \"\"\"\n        return self.add_field('funcName', fmt)\n\n    def add_levelname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n        return self.add_field('levelname', fmt)\n\n    def add_levelno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n        return self.add_field('levelno', fmt)\n\n    def add_lineno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Source line number where the logging call was issued (if available). \"\"\"\n        return self.add_field('lineno', fmt)\n\n    def add_message(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" The logged message, computed as msg % args. This is set when Formatter.format() is invoked. \"\"\"\n        return self.add_field('message', fmt)\n\n    def add_module(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Module (name portion of filename). \"\"\"\n        return self.add_field('module', fmt)\n\n    def add_msecs(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Millisecond portion of the time when the LogRecord was created. \"\"\"\n        return self.add_field('msecs', fmt)\n\n    def add_name(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Name of the logger used to log the call. \"\"\"\n        return self.add_field('name', fmt)\n\n    def add_pathname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Full pathname of the source file where the logging call was issued (if available). \"\"\"\n        return self.add_field('pathname', fmt)\n\n    def add_process(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Process ID (if available) \"\"\"\n        return self.add_field('process', fmt)\n\n    def add_processname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Process name (if available) \"\"\"\n        return self.add_field('processName', fmt)\n\n    def add_relativecreated(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.\"\"\"\n        return self.add_field('relativeCreated', fmt)\n\n    def add_thread(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Thread ID (if available) \"\"\"\n        return self.add_field('thread', fmt)\n\n    def add_threadname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Thread name (if available) \"\"\"\n        return self.add_field('threadName', fmt)\n\n    def add_taskname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" asyncio.Task name (if available) \"\"\"\n        return self.add_field('taskName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_asctime","title":"<code>add_asctime(fmt=None)</code>","text":"<p>Human-readable time when the LogRecord was created. By default, this is of the form \u20182003-07-08 16:49:45,896\u2019 (the numbers after the comma are millisecond portion of the time).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_asctime(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\"\n    Human-readable time when the LogRecord was created.\n    By default, this is of the form \u20182003-07-08 16:49:45,896\u2019\n    (the numbers after the comma are millisecond portion of the time).\n    \"\"\"\n    return self.add_field('asctime', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_created","title":"<code>add_created(fmt=None)</code>","text":"<p>Time when the LogRecord was created (as returned by time.time()).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_created(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Time when the LogRecord was created (as returned by time.time()). \"\"\"\n    return self.add_field('created', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_field","title":"<code>add_field(name, fmt=None)</code>","text":"<p>adds a custom field</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_field(self, name: str, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" adds a custom field \"\"\"\n    if fmt is None:\n        self._parts.append(f\"{{{name}}}\")\n    else:\n        self._parts.append(f\"{{{name}:{fmt}}}\")\n    return self\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_filename","title":"<code>add_filename(fmt=None)</code>","text":"<p>Filename portion of pathname.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_filename(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Filename portion of pathname. \"\"\"\n    return self.add_field('filename', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_funcname","title":"<code>add_funcname(fmt=None)</code>","text":"<p>Name of function containing the logging call.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_funcname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Name of function containing the logging call. \"\"\"\n    return self.add_field('funcName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_levelname","title":"<code>add_levelname(fmt=None)</code>","text":"<p>Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_levelname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n    return self.add_field('levelname', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_levelno","title":"<code>add_levelno(fmt=None)</code>","text":"<p>Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_levelno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n    return self.add_field('levelno', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_lineno","title":"<code>add_lineno(fmt=None)</code>","text":"<p>Source line number where the logging call was issued (if available).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_lineno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Source line number where the logging call was issued (if available). \"\"\"\n    return self.add_field('lineno', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_literal","title":"<code>add_literal(literal)</code>","text":"<p>adds a literal string as given</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_literal(self, literal: str) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" adds a literal string as given \"\"\"\n    self._parts.append(literal)\n    return self\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_message","title":"<code>add_message(fmt=None)</code>","text":"<p>The logged message, computed as msg % args. This is set when Formatter.format() is invoked.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_message(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" The logged message, computed as msg % args. This is set when Formatter.format() is invoked. \"\"\"\n    return self.add_field('message', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_module","title":"<code>add_module(fmt=None)</code>","text":"<p>Module (name portion of filename).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_module(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Module (name portion of filename). \"\"\"\n    return self.add_field('module', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_msecs","title":"<code>add_msecs(fmt=None)</code>","text":"<p>Millisecond portion of the time when the LogRecord was created.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_msecs(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Millisecond portion of the time when the LogRecord was created. \"\"\"\n    return self.add_field('msecs', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_name","title":"<code>add_name(fmt=None)</code>","text":"<p>Name of the logger used to log the call.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_name(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Name of the logger used to log the call. \"\"\"\n    return self.add_field('name', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_pathname","title":"<code>add_pathname(fmt=None)</code>","text":"<p>Full pathname of the source file where the logging call was issued (if available).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_pathname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Full pathname of the source file where the logging call was issued (if available). \"\"\"\n    return self.add_field('pathname', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_process","title":"<code>add_process(fmt=None)</code>","text":"<p>Process ID (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_process(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Process ID (if available) \"\"\"\n    return self.add_field('process', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_processname","title":"<code>add_processname(fmt=None)</code>","text":"<p>Process name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_processname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Process name (if available) \"\"\"\n    return self.add_field('processName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_relativecreated","title":"<code>add_relativecreated(fmt=None)</code>","text":"<p>Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_relativecreated(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.\"\"\"\n    return self.add_field('relativeCreated', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_taskname","title":"<code>add_taskname(fmt=None)</code>","text":"<p>asyncio.Task name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_taskname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" asyncio.Task name (if available) \"\"\"\n    return self.add_field('taskName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_thread","title":"<code>add_thread(fmt=None)</code>","text":"<p>Thread ID (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_thread(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Thread ID (if available) \"\"\"\n    return self.add_field('thread', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.add_threadname","title":"<code>add_threadname(fmt=None)</code>","text":"<p>Thread name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_threadname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Thread name (if available) \"\"\"\n    return self.add_field('threadName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/#loggext.formatting.LoggingFormatBuilder.build","title":"<code>build()</code>","text":"<p>create the final logging-format</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def build(self) -&gt; str:\n    r\"\"\" create the final logging-format \"\"\"\n    return self._separator.join(self._parts)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/","title":"loggext.formatting.builder","text":""},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder","title":"<code>LoggingFormatBuilder</code>","text":"<pre><code>&gt;&gt;&gt; logging_format: str = LoggingFormatBuilder(separator=\" | \") \\\n...     .add_asctime() \\\n...     .add_levelname(\".3\") \\\n...     .add_module(\"&lt;10\") \\\n...     .add_lineno(\"&gt;3\") \\\n...     .add_message() \\\n...     .build()\n</code></pre> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>class LoggingFormatBuilder:\n    r\"\"\"\n    ```pycon\n\n    &gt;&gt;&gt; logging_format: str = LoggingFormatBuilder(separator=\" | \") \\\n    ...     .add_asctime() \\\n    ...     .add_levelname(\".3\") \\\n    ...     .add_module(\"&lt;10\") \\\n    ...     .add_lineno(\"&gt;3\") \\\n    ...     .add_message() \\\n    ...     .build()\n\n    ```\n    \"\"\"\n\n    _separator: str\n    _parts: t.List[str]\n\n    def __init__(self, *, separator: str = \":\"):\n        self._separator = separator\n        self._parts = []\n\n    def build(self) -&gt; str:\n        r\"\"\" create the final logging-format \"\"\"\n        return self._separator.join(self._parts)\n\n    def add_field(self, name: str, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" adds a custom field \"\"\"\n        if fmt is None:\n            self._parts.append(f\"{{{name}}}\")\n        else:\n            self._parts.append(f\"{{{name}:{fmt}}}\")\n        return self\n\n    def add_literal(self, literal: str) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" adds a literal string as given \"\"\"\n        self._parts.append(literal)\n        return self\n\n    def add_asctime(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\"\n        Human-readable time when the LogRecord was created.\n        By default, this is of the form \u20182003-07-08 16:49:45,896\u2019\n        (the numbers after the comma are millisecond portion of the time).\n        \"\"\"\n        return self.add_field('asctime', fmt)\n\n    def add_created(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Time when the LogRecord was created (as returned by time.time()). \"\"\"\n        return self.add_field('created', fmt)\n\n    def add_filename(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Filename portion of pathname. \"\"\"\n        return self.add_field('filename', fmt)\n\n    def add_funcname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Name of function containing the logging call. \"\"\"\n        return self.add_field('funcName', fmt)\n\n    def add_levelname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n        return self.add_field('levelname', fmt)\n\n    def add_levelno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n        return self.add_field('levelno', fmt)\n\n    def add_lineno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Source line number where the logging call was issued (if available). \"\"\"\n        return self.add_field('lineno', fmt)\n\n    def add_message(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" The logged message, computed as msg % args. This is set when Formatter.format() is invoked. \"\"\"\n        return self.add_field('message', fmt)\n\n    def add_module(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Module (name portion of filename). \"\"\"\n        return self.add_field('module', fmt)\n\n    def add_msecs(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Millisecond portion of the time when the LogRecord was created. \"\"\"\n        return self.add_field('msecs', fmt)\n\n    def add_name(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Name of the logger used to log the call. \"\"\"\n        return self.add_field('name', fmt)\n\n    def add_pathname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Full pathname of the source file where the logging call was issued (if available). \"\"\"\n        return self.add_field('pathname', fmt)\n\n    def add_process(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Process ID (if available) \"\"\"\n        return self.add_field('process', fmt)\n\n    def add_processname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Process name (if available) \"\"\"\n        return self.add_field('processName', fmt)\n\n    def add_relativecreated(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.\"\"\"\n        return self.add_field('relativeCreated', fmt)\n\n    def add_thread(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Thread ID (if available) \"\"\"\n        return self.add_field('thread', fmt)\n\n    def add_threadname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" Thread name (if available) \"\"\"\n        return self.add_field('threadName', fmt)\n\n    def add_taskname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n        r\"\"\" asyncio.Task name (if available) \"\"\"\n        return self.add_field('taskName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_asctime","title":"<code>add_asctime(fmt=None)</code>","text":"<p>Human-readable time when the LogRecord was created. By default, this is of the form \u20182003-07-08 16:49:45,896\u2019 (the numbers after the comma are millisecond portion of the time).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_asctime(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\"\n    Human-readable time when the LogRecord was created.\n    By default, this is of the form \u20182003-07-08 16:49:45,896\u2019\n    (the numbers after the comma are millisecond portion of the time).\n    \"\"\"\n    return self.add_field('asctime', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_created","title":"<code>add_created(fmt=None)</code>","text":"<p>Time when the LogRecord was created (as returned by time.time()).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_created(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Time when the LogRecord was created (as returned by time.time()). \"\"\"\n    return self.add_field('created', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_field","title":"<code>add_field(name, fmt=None)</code>","text":"<p>adds a custom field</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_field(self, name: str, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" adds a custom field \"\"\"\n    if fmt is None:\n        self._parts.append(f\"{{{name}}}\")\n    else:\n        self._parts.append(f\"{{{name}:{fmt}}}\")\n    return self\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_filename","title":"<code>add_filename(fmt=None)</code>","text":"<p>Filename portion of pathname.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_filename(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Filename portion of pathname. \"\"\"\n    return self.add_field('filename', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_funcname","title":"<code>add_funcname(fmt=None)</code>","text":"<p>Name of function containing the logging call.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_funcname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Name of function containing the logging call. \"\"\"\n    return self.add_field('funcName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_levelname","title":"<code>add_levelname(fmt=None)</code>","text":"<p>Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_levelname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n    return self.add_field('levelname', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_levelno","title":"<code>add_levelno(fmt=None)</code>","text":"<p>Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_levelno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL). \"\"\"\n    return self.add_field('levelno', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_lineno","title":"<code>add_lineno(fmt=None)</code>","text":"<p>Source line number where the logging call was issued (if available).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_lineno(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Source line number where the logging call was issued (if available). \"\"\"\n    return self.add_field('lineno', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_literal","title":"<code>add_literal(literal)</code>","text":"<p>adds a literal string as given</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_literal(self, literal: str) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" adds a literal string as given \"\"\"\n    self._parts.append(literal)\n    return self\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_message","title":"<code>add_message(fmt=None)</code>","text":"<p>The logged message, computed as msg % args. This is set when Formatter.format() is invoked.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_message(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" The logged message, computed as msg % args. This is set when Formatter.format() is invoked. \"\"\"\n    return self.add_field('message', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_module","title":"<code>add_module(fmt=None)</code>","text":"<p>Module (name portion of filename).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_module(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Module (name portion of filename). \"\"\"\n    return self.add_field('module', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_msecs","title":"<code>add_msecs(fmt=None)</code>","text":"<p>Millisecond portion of the time when the LogRecord was created.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_msecs(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Millisecond portion of the time when the LogRecord was created. \"\"\"\n    return self.add_field('msecs', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_name","title":"<code>add_name(fmt=None)</code>","text":"<p>Name of the logger used to log the call.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_name(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Name of the logger used to log the call. \"\"\"\n    return self.add_field('name', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_pathname","title":"<code>add_pathname(fmt=None)</code>","text":"<p>Full pathname of the source file where the logging call was issued (if available).</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_pathname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Full pathname of the source file where the logging call was issued (if available). \"\"\"\n    return self.add_field('pathname', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_process","title":"<code>add_process(fmt=None)</code>","text":"<p>Process ID (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_process(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Process ID (if available) \"\"\"\n    return self.add_field('process', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_processname","title":"<code>add_processname(fmt=None)</code>","text":"<p>Process name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_processname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Process name (if available) \"\"\"\n    return self.add_field('processName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_relativecreated","title":"<code>add_relativecreated(fmt=None)</code>","text":"<p>Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_relativecreated(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.\"\"\"\n    return self.add_field('relativeCreated', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_taskname","title":"<code>add_taskname(fmt=None)</code>","text":"<p>asyncio.Task name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_taskname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" asyncio.Task name (if available) \"\"\"\n    return self.add_field('taskName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_thread","title":"<code>add_thread(fmt=None)</code>","text":"<p>Thread ID (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_thread(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Thread ID (if available) \"\"\"\n    return self.add_field('thread', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.add_threadname","title":"<code>add_threadname(fmt=None)</code>","text":"<p>Thread name (if available)</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def add_threadname(self, fmt: str = None) -&gt; 'LoggingFormatBuilder':\n    r\"\"\" Thread name (if available) \"\"\"\n    return self.add_field('threadName', fmt)\n</code></pre>"},{"location":"reference/loggext/formatting/builder/#loggext.formatting.builder.LoggingFormatBuilder.build","title":"<code>build()</code>","text":"<p>create the final logging-format</p> Source code in <code>src/loggext/formatting/builder.py</code> <pre><code>def build(self) -&gt; str:\n    r\"\"\" create the final logging-format \"\"\"\n    return self._separator.join(self._parts)\n</code></pre>"},{"location":"reference/loggext/formatting/default_formats/","title":"loggext.formatting.default_formats","text":""},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.ASYNC","title":"<code>ASYNC = '{asctime} | {levelname:.3} | {taskName:&gt;10} | {message}'</code>  <code>module-attribute</code>","text":"<p>useful when doing asnyc-code</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.DEBUGGING","title":"<code>DEBUGGING = '{asctime} | {levelname:.3} | {name:&gt;15} | {funcName:&gt;12} | {lineno:&gt;3} | {message}'</code>  <code>module-attribute</code>","text":"<p>format with all the information you need to find where the error comes from</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.LEVEL_MESSAGE","title":"<code>LEVEL_MESSAGE = '{levelname:.3} | {message}'</code>  <code>module-attribute</code>","text":"<p>minimalistic design with the logged information and the severity</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.MESSAGE","title":"<code>MESSAGE = '{message}'</code>  <code>module-attribute</code>","text":"<p>minimalistic design with only the logged information</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.MINIMAL","title":"<code>MINIMAL = '{asctime} | {levelname:.3} | {name:&gt;15} | {message}'</code>  <code>module-attribute</code>","text":"<p>this is a simple format which includes the time, level, logger-name and message</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.PROCESSING","title":"<code>PROCESSING = '{asctime} | {levelname:.3} | {process:&gt;5} | {message}'</code>  <code>module-attribute</code>","text":"<p>useful when doing multi-processing</p>"},{"location":"reference/loggext/formatting/default_formats/#loggext.formatting.default_formats.THREADED","title":"<code>THREADED = '{asctime} | {levelname:.3} | {thread:&gt;3} | {message}'</code>  <code>module-attribute</code>","text":"<p>useful when doing multi-threading</p>"},{"location":"reference/loggext/handlers/","title":"loggext.handlers","text":""},{"location":"reference/loggext/handlers/#loggext.handlers.ColoredConsoleHandler","title":"<code>ColoredConsoleHandler</code>","text":"<p>               Bases: <code>StreamHandler</code></p> <p>same as <code>StreamHandler</code> but with colored output based on the logging-level of each message</p> Source code in <code>src/loggext/handlers/colored.py</code> <pre><code>class ColoredConsoleHandler(logging.StreamHandler):\n    r\"\"\"\n    same as `StreamHandler` but with colored output based on the logging-level of each message\n    \"\"\"\n    STDOUT = sys.stdout\n    STDERR = sys.stderr\n\n    def format(self, record):\n        colorcode = COLOR_MAP.get(record.levelno)\n        msg = super().format(record)\n        if colorcode is None:\n            return msg\n        return f\"{colorcode}{msg}{ENDCOLOR}\"\n</code></pre>"},{"location":"reference/loggext/handlers/#loggext.handlers.LevelColoredConsoleHandler","title":"<code>LevelColoredConsoleHandler</code>","text":"<p>               Bases: <code>StreamHandler</code></p> <p>similar to <code>ColoredConsoleHandler</code> but colors only the levelname</p> Source code in <code>src/loggext/handlers/colored.py</code> <pre><code>class LevelColoredConsoleHandler(logging.StreamHandler):\n    r\"\"\"\n    similar to `ColoredConsoleHandler` but colors only the levelname\n    \"\"\"\n    STDOUT = sys.stdout\n    STDERR = sys.stderr\n\n    def emit(self, record):\n        colorcode = COLOR_MAP.get(record.levelno)\n        if colorcode is not None:\n            record = logging.makeLogRecord(record.__dict__)  # copy to not modify for other logging-handlers\n            record.levelname = f\"{colorcode}{record.levelname}{ENDCOLOR}\"\n        super().emit(record)\n</code></pre>"},{"location":"reference/loggext/handlers/colored/","title":"loggext.handlers.colored","text":""},{"location":"reference/loggext/handlers/colored/#loggext.handlers.colored.COLOR_MAP","title":"<code>COLOR_MAP: t.Dict[int, str] = {logging.DEBUG: StandardColors.BRIGHT_BLACK.escape_code_fg, logging.INFO: StandardColors.BRIGHT_BLUE.escape_code_fg, logging.WARN: StandardColors.BRIGHT_YELLOW.escape_code_fg, logging.ERROR: StandardColors.BRIGHT_RED.escape_code_fg, logging.CRITICAL: StandardColors.BRIGHT_MAGENTA.escape_code_fg}</code>  <code>module-attribute</code>","text":"<p>This can be adjusted/extended for custom coloring</p>"},{"location":"reference/loggext/handlers/colored/#loggext.handlers.colored.ColoredConsoleHandler","title":"<code>ColoredConsoleHandler</code>","text":"<p>               Bases: <code>StreamHandler</code></p> <p>same as <code>StreamHandler</code> but with colored output based on the logging-level of each message</p> Source code in <code>src/loggext/handlers/colored.py</code> <pre><code>class ColoredConsoleHandler(logging.StreamHandler):\n    r\"\"\"\n    same as `StreamHandler` but with colored output based on the logging-level of each message\n    \"\"\"\n    STDOUT = sys.stdout\n    STDERR = sys.stderr\n\n    def format(self, record):\n        colorcode = COLOR_MAP.get(record.levelno)\n        msg = super().format(record)\n        if colorcode is None:\n            return msg\n        return f\"{colorcode}{msg}{ENDCOLOR}\"\n</code></pre>"},{"location":"reference/loggext/handlers/colored/#loggext.handlers.colored.LevelColoredConsoleHandler","title":"<code>LevelColoredConsoleHandler</code>","text":"<p>               Bases: <code>StreamHandler</code></p> <p>similar to <code>ColoredConsoleHandler</code> but colors only the levelname</p> Source code in <code>src/loggext/handlers/colored.py</code> <pre><code>class LevelColoredConsoleHandler(logging.StreamHandler):\n    r\"\"\"\n    similar to `ColoredConsoleHandler` but colors only the levelname\n    \"\"\"\n    STDOUT = sys.stdout\n    STDERR = sys.stderr\n\n    def emit(self, record):\n        colorcode = COLOR_MAP.get(record.levelno)\n        if colorcode is not None:\n            record = logging.makeLogRecord(record.__dict__)  # copy to not modify for other logging-handlers\n            record.levelname = f\"{colorcode}{record.levelname}{ENDCOLOR}\"\n        super().emit(record)\n</code></pre>"},{"location":"reference/loggext/utility/","title":"loggext.utility","text":""},{"location":"reference/loggext/utility/#loggext.utility.StandardColors","title":"<code>StandardColors</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>collection of standard colors for the terminal</p> Source code in <code>src/loggext/utility/_color.py</code> <pre><code>class StandardColors(enum.IntEnum):\n    r\"\"\"\n    collection of standard colors for the terminal\n    \"\"\"\n\n    def __new__(cls, ansi_code: int, rgb: t.Tuple[int, int, int], hexadecimal: str) -&gt; t.NoReturn:\n        obj = int.__new__(cls, ansi_code)\n        obj._value_ = ansi_code\n        obj.ansi_code = ansi_code\n        obj.rgb = rgb\n        obj.hexadecimal = hexadecimal\n        # normal color: 30fg/40bg | bright colors 90fg/100bg\n        obj.escape_code_fg = f\"\\033[{(30 + ansi_code) if ansi_code &lt; 0x8 else (82 + ansi_code)}m\"\n        obj.escape_code_bg = f\"\\033[{(40 + ansi_code) if ansi_code &lt; 0x8 else (92 + ansi_code)}m\"\n        return obj\n\n    BLACK           = 0x0, (0,   0,   0),   \"#000000\"\n    RED             = 0x1, (204, 0,   0),   \"#CC0000\"\n    GREEN           = 0x2, (78,  154, 6),   \"#4E9A06\"\n    YELLOW          = 0x3, (196, 160, 0),   \"#C4A000\"\n    BLUE            = 0x4, (114, 159, 207), \"#729FCF\"\n    MAGENTA         = 0x5, (117, 80,  123), \"#75507B\"\n    CYAN            = 0x6, (6,   152, 154), \"#06989A\"\n    WHITE           = 0x7, (211, 215, 207), \"#D3D7CF\"\n    BRIGHT_BLACK    = 0x8, (85,  87,  83),  \"#555753\"\n    BRIGHT_RED      = 0x9, (239, 41,  41),  \"#EF2929\"\n    BRIGHT_GREEN    = 0xA, (138, 226, 52),  \"#8AE234\"\n    BRIGHT_YELLOW   = 0xB, (252, 233, 79),  \"#FCE94F\"\n    BRIGHT_BLUE     = 0xC, (50,  175, 255), \"#32AFFf\"\n    BRIGHT_MAGENTA  = 0xD, (173, 127, 168), \"#AD7FA8\"\n    BRIGHT_CYAN     = 0xE, (52,  226, 226), \"#34E2E2\"\n    BRIGHT_WHITE    = 0xF, (255, 255, 255), \"#FFFFFF\"\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.is_running_as_service","title":"<code>is_running_as_service()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if the current script is running as a service (or not)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def is_running_as_service() -&gt; bool:\n    r\"\"\"\n    :return: if the current script is running as a service (or not)\n    \"\"\"\n    return os.getenv('TERM') is None and os.isatty(sys.stdin.fileno())\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.is_running_in_shell","title":"<code>is_running_in_shell()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if the current script is running in a shell (or not)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def is_running_in_shell() -&gt; bool:\n    r\"\"\"\n    :return: if the current script is running in a shell (or not)\n    \"\"\"\n    return os.isatty(sys.stdin.fileno())\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.logging_is_configured","title":"<code>logging_is_configured()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>if :func:<code>logging.basicConfig</code> was already called. (if the root-logger has handlers)</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def logging_is_configured() -&gt; bool:\n    r\"\"\"\n    :return: if :func:`logging.basicConfig` was already called. (if the root-logger has handlers)\n    \"\"\"\n    return len(logging.root.handlers) &gt; 0\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.no_multiprocess_info","title":"<code>no_multiprocess_info()</code>","text":"<p>disabled multiprocessing-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_multiprocess_info():\n    r\"\"\" disabled multiprocessing-information in the LogRecord for slight performance boost \"\"\"\n    logging.logMultiprocessing = False\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.no_process_info","title":"<code>no_process_info()</code>","text":"<p>disabled process-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_process_info():\n    r\"\"\" disabled process-information in the LogRecord for slight performance boost \"\"\"\n    logging.logProcess = False\n</code></pre>"},{"location":"reference/loggext/utility/#loggext.utility.no_thread_info","title":"<code>no_thread_info()</code>","text":"<p>disabled threading-information in the LogRecord for slight performance boost</p> Source code in <code>src/loggext/utility/_impl.py</code> <pre><code>def no_thread_info():\n    r\"\"\" disabled threading-information in the LogRecord for slight performance boost \"\"\"\n    logging.logThreads = False\n</code></pre>"},{"location":"usage/decorators/","title":"loggext.decorators","text":""},{"location":"usage/decorators/#add_logging","title":"add_logging","text":"<p>The <code>add_logging</code> decorator can quickly add logging to a function or method which can help during debugging.</p> <p>The logging-messages include:</p> <ul> <li>when the function is called and with which arguments</li> <li>when the function returns, how long it took and what was returned</li> <li>when the function failed and an exception is raised</li> </ul> <pre><code>import logging\nfrom loggext.decorators import add_logging\n\nlogger = logging.getLogger(__name__)\n\n@add_logging(\n  logger=logger,  # (1)\n  call=True,  # (2)\n  call_args=True,  # (3)\n  timeit=True,   # (4)\n  timeit_precision=2,  # (5)\n  result=True,  # (6)\n)\ndef myfn(arg):\n    ...  # your code\n\nmyfn(\"value\")\n# DEBUG:root:&lt;function myfn at 0x7f06a6cc3400&gt; was called with ('value')\n# DEBUG:root:&lt;function myfn at 0x7f06a6cc3400&gt; returned None after 65\u03bcs+614ns\n</code></pre> <ol> <li>species a custom logger</li> <li>whether to log when the function is called</li> <li>whether to log the passed arguments of the function-call.</li> <li>whether to measure the performance of the function</li> <li>number of units when formatting the timing.     1: 65\u03bcs     2: 65\u03bcs+614ns</li> <li>whether to log the returned value</li> </ol>"},{"location":"usage/decorators/#async-functions","title":"async functions","text":"<p>The <code>add_logging</code> decorator also supports asnyc-functions.</p> <pre><code>from loggext.decorators import add_logging\n\n@add_logging()\nasync def async_function():\n    ...  # your code\n</code></pre>"},{"location":"usage/decorators/#performance","title":"Performance","text":"<p>Worried about the performance? You don't need to!</p> <p>If your logger is not configured for <code>logging.DEBUG</code> messages then they are neither generated nor logged. This way no computation is wasted to e.g. convert the complex function-arguments to their representative form.</p>"},{"location":"usage/extradata/","title":"loggext.extradata","text":"<p>The attribute from the normal <code>logging.LogRecord</code> are quite good but can be extended. For that case there are some providers in loggext.extradata which inject additional fields.</p> <p>This allows you to add (e.g.) the hostname of the current device to your log-message.</p> <p>Example</p> <pre><code>import logging\nfrom loggext.extradata import ProgramNameField\n\nlogging.basicConfig(\n   format='%(programName)s | %(message)',\n)\nProgramNameField().install()  # (1)\n\nlogging.info(\"Hello World\")  # \"script.py | Hello World\" (2)\n</code></pre> <ol> <li>This adds the <code>programName</code>-field to all handlers of the root-logger. This way you can use <code>logging.getLogger(__name__)</code> in sub-packages without getting an error because of a missing field.</li> <li>Example output</li> </ol>"},{"location":"usage/formatting/","title":"loggext.formatting","text":"<p>loggext offers some pre-defined formats in loggext.formatting.default_formats.</p>"},{"location":"usage/formatting/#loggingformatbuilder","title":"LoggingFormatBuilder","text":"<p>If you like your own format you can use the LoggingFormatBuilder to create the logging-format in a more humane or dynamic way.</p> <pre><code>from loggext.formatting import LoggingFormatBuilder\n\nlogging_format: str = LoggingFormatBuilder(separator=\" | \") \\\n     .add_asctime() \\\n     .add_levelname(\".3\") \\\n     .add_module(\"&lt;10\") \\\n     .add_lineno(\"&gt;3\") \\\n     .add_message() \\\n     .build()\n# '{asctime} | {levelname:.3} | {module:&lt;10} | {lineno:&gt;3} | {message}'\n</code></pre>"},{"location":"usage/handlers/","title":"loggext.handlers","text":""},{"location":"usage/handlers/#coloredconsolehandler","title":"ColoredConsoleHandler","text":"<p>The ColoredConsoleHandler is similar to the <code>logging.StreamHandler</code> with the difference of colored output.</p> <p>The color is dependent on the logging-level.</p>"},{"location":"usage/handlers/#levelcoloredconsolehandler","title":"LevelColoredConsoleHandler","text":"<p>If you don't like it as colorful there is also the LevelColoredConsoleHandler. This one also colors the output, but only the <code>%(level)s</code> part and not the whole message.</p>"},{"location":"usage/utility/","title":"loggext.utility","text":""}]}